#+title: Readme

* Advent of Code 2022!!

* Setup
#+name: input-loader
#+begin_src emacs-lisp :var filename=input.txt
(with-temp-buffer
  (insert-file-contents filename)
  (format "%s" (buffer-string)))
#+end_src

* Day 1
Example input:
#+name: example-input-1
#+begin_example
1000
2000
3000

4000

5000
6000

7000
8000
9000

10000
#+end_example

Loading the puzzle input from a file:
#+name: input-1
#+call: input-loader("input1.txt") :results none

** Part 1
For this we can first treat the input. It gets a little tricky because the
input uses an empty line to split things, and ~elisp~ (or at least what I
know about it) does not work well with that, so we replace it with ~:~, then
if you use ~::~ it will split the /elfs/ and then use ~:~ to split their
calories numbers into a list, converting them to numbers. Then we just add
all of them and extract the maximum.

#+name: max-total-calories
#+begin_src emacs-lisp :var input=example-input-1
(seq-max (mapcar (lambda (i)
                   (apply '+ i))
                 (mapcar '(lambda (l)
                            (mapcar 'string-to-number (s-split ":" l)))
                         (s-split "::" (s-replace "\n" ":" input)))))

#+end_src

#+RESULTS: max-total-calories
: 24000

Overall the complexity of this algorithm should be ~O(n)~ as we just scan
the input list a fixed amount of times, given that the calories values are
"small", otherwise the /string-to-number/ conversion can also add one level
of complexity, changing it to ~O(kn)~ where ~k~ is the number of digits in
the calories.

 #+call: max-total-calories(input-1)

 #+RESULTS:
 : 68787

** Part 2
For part two, the logic doesn't change much for parsing and conversion, the
only extra processing we need to do is get the 3 maximum values instead
of just one, we can do that lazily just by sorting the list in descending
order and getting the first 3 values and adding them.

#+name: top3-max-total-calories
#+begin_src emacs-lisp :var input=example-input-1
(apply '+ (subseq (sort (mapcar '(lambda (i) (apply '+ i))
                                (mapcar '(lambda (l)
                                           (mapcar 'string-to-number
                                                   (s-split ":" l)))
                                        (s-split "::" (s-replace "\n" ":" input))))
                        '>)
                  0 3))
#+end_src

#+RESULTS: top3-max-total-calories
: 45000

Overall the complexity here becomes ~O(nlog(n))~ as it performs a merge-sort.
We could reduce the complexity to ~O(n)~ by using something like finding the
maximum, removing it from the list and repeating that 2 other times with
the resulting list.

#+call: top3-max-total-calories(input-1)

#+RESULTS:
: 198041

* Day 2
Example input:
#+name: example-input-2
#+begin_example
A Y
B X
C Z
#+end_example

Loading the puzzle input from a file:
#+name: input-2
#+call: input-loader("input2.txt") :results none

** Part 1
For this, the solution is easier, as we just need to map all the possible
point combinations (only 9 of them) and then use /pattern-matching/ over the
input rounds, adding them all up.

#+name: strategy-score
#+begin_src emacs-lisp :var input=example-input-2
(apply '+ (mapcar '(lambda (r) (pcase r
                                 ('("A" "X") (+ 1 3))
                                 ('("A" "Y") (+ 2 6))
                                 ('("A" "Z") (+ 3 0))
                                 ('("B" "X") (+ 1 0))
                                 ('("B" "Y") (+ 2 3))
                                 ('("B" "Z") (+ 3 6))
                                 ('("C" "X") (+ 1 6))
                                 ('("C" "Y") (+ 2 0))
                                 ('("C" "Z") (+ 3 3))))
                  (seq-partition (split-string input) 2)))
#+end_src

#+RESULTS: strategy-score
: 15

Overall complexity of the algorithm is ~O(n)~ as we only scan through the
input to get the points for each round, then reduce the list in one go into
its sum.

 #+call: strategy-score(input-2)

 #+RESULTS:
 : 12156

** Part 2
For this, we just need to change the pattern matching values to reflect the
changes, taking a little effort to figure out beforehand what is the points
for each scenario.

#+name: real-strategy-score
#+begin_src emacs-lisp :var input=example-input-2
(apply '+ (mapcar '(lambda (r) (pcase r
                                 ('("A" "X") (+ 0 3))
                                 ('("A" "Y") (+ 3 1))
                                 ('("A" "Z") (+ 6 2))
                                 ('("B" "X") (+ 0 1))
                                 ('("B" "Y") (+ 3 2))
                                 ('("B" "Z") (+ 6 3))
                                 ('("C" "X") (+ 0 2))
                                 ('("C" "Y") (+ 3 3))
                                 ('("C" "Z") (+ 6 1))))
                  (seq-partition (split-string input) 2)))
#+end_src

#+RESULTS: real-strategy-score
: 12

The complexity does not change from the first part.

#+call: real-strategy-score(input-2)

#+RESULTS:
: 10835

* Day 3
Example input:
#+name: example-input-3
#+begin_example
vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
#+end_example


Loading the puzzle input from a file:
#+name: input-3
#+call: input-loader("input3.txt") :results none

** Part 1
To solve this, we just need to, after parsing the inputs, split the rucksacks
in half, apply an intersection between them and using the result, convert the
character into a priority value using the ~ASCI~ value for the character.
After that, we can reduce the list of priorities into a sum.

#+name: priority-sum
#+begin_src emacs-lisp :var input=example-input-3
(apply '+ (mapcar '(lambda (r) (let* ((len (seq-length r)) (m (/ len 2)))
                                 (let ((p (car (cl-intersection (string-to-list (subseq r 0 m))
                                                                (string-to-list (subseq r m len))))))
                                   (if (> p 96)
                                       (- p 96)
                                     (- p 38)))))
                  (split-string input)))
#+end_src

#+RESULTS: priority-sum
: 157

The overall complexity of this algorithm should be ~O(n)~, as the length of
the input string for each rucksack is limited to at most ~26+27=53~ elements
as we are told the elf only failed for exactly one item. this leaves the
complexity of the ~intersection~ function (which depends on several calls to
~membership~ checks). This makes the constants for the complexity a lot higher
so when run with other intersection algorithms that use hashing or similar
methods we could see great performance gains.

#+call: priority-sum(input-3)

#+RESULTS:
: 7581

** Part 2
This version is similar to the first part, as it also requires us to use set
operations to figure out the item type that is an intersection between all
three groups, and then the priority value comes in just as before.
Here we use the ~cadr caddr~ functions which are created as macros that evaluate
to ~(car (cdr l))~ and ~(car (cdr (cdr l)))~. The ~car~ and ~cdr~ functions
take the head and tail of the input list, so we can translate ~cadr~ into
/the head of the tail of the list/ and ~caddr~ into /the head of the tail of/
/the list obtained after taking the tail of the list/ which in turn translate
to taking the first element with ~car~, the second with ~cadr~ and the third
with ~caddr~.

#+name: group-priority-sum
#+begin_src emacs-lisp :var input=example-input-3
(apply '+ (mapcar '(lambda (g) (let ((p (car (cl-intersection
                                              (string-to-list (caddr g))
                                              (cl-intersection (string-to-list (car g))
                                                               (string-to-list (cadr g)))))))
                                 (if (> p 96)
                                     (- p 96)
                                   (- p 38))))
                  (seq-partition (split-string input) 3)))
#+end_src

#+RESULTS: group-priority-sum
: 70

The complexity now is the same as before ~O(n)~ as the intersection function
is applied twice over 3 limited length lists, and the ~partition~ can be done
in linear time.

#+call: group-priority-sum(input-3)

#+RESULTS:
: 2525

* Day 4
Example input:
#+name: example-input-4
#+begin_example
2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8
#+end_example


Loading the puzzle input from a file:
#+name: input-4
#+call: input-loader("input4.txt") :results none

** Part 1
For this puzzle, other than parsing the input, we need to realize what does it
mean to have a fully contained interval, that is, the starting number and
ending number of the smaller interval must be less then or equal to the
starting number and ending number of the bigger interval. We can check this
by first finding the earliest starting interval, this must be the /bigger/
interval for us to have a full coverage, so we check that the other interval's
start and end is contained within the earliest starting interval.

#+name: fully-contained-amount
#+begin_src emacs-lisp :var input=example-input-4
(defun split-dash-number (in)
    "split string by dash and convert to number"
    (mapcar #'string-to-number (s-split "-" in)))
(apply #'+ (mapcar '(lambda (g) (let* ((r (mapcar #'split-dash-number g))
                                       (s1 (caar r))
                                       (e1 (cadar r))
                                       (s2 (caadr r))
                                       (e2 (cadadr r)))
                                  (if (or (and (<= s1 s2)
                                               (<= e2 e1))
                                          (and (<= s2 s1)
                                               (<= e1 e2)))
                                      1
                                    0)))
                   (mapcar '(lambda (l) (s-split "," l))
                           (split-string input))))

#+end_src

#+RESULTS: fully-contained-amount
: 2

The overall complexity of this algorithm is ~O(n)~ as we only scan through
the list of inputs once, doing ~O(1)~ comparisons.

#+call: fully-contained-amount(input-4)

#+RESULTS:
: 588

** Part 2
The second part covers a broader problem, where we are not trying to find only
the full coverage, but only the intervals where there is any overlap. We do
this by checking that either end of both intervals are contained on the limits
of the other interval, /e.g./: for intervals 2-4 and 3-6 we check:

1. ~3 >= 2 >= 6~
2. ~3 >= 4 >= 6~ ***
3. ~2 >= 3 >= 4~ ***
4. ~2 >= 6 >= 4~

Where you can see that both ~2.~ and ~3.~ indicate an overlap.

#+name: overlap-count
#+begin_src emacs-lisp :var input=example-input-4
(defun split-dash-number (in)
    "split string by dash and convert to number"
    (mapcar #'string-to-number (s-split "-" in)))
(apply #'+ (mapcar '(lambda (g) (let* ((r (mapcar #'split-dash-number g))
                                       (s1 (caar r))
                                       (e1 (cadar r))
                                       (s2 (caadr r))
                                       (e2 (cadadr r)))
                                  (if (or (and (>= s2 s1)
                                               (<= s2 e1))
                                          (and (>= e2 s1)
                                               (<= e2 e1))
                                          (and (>= s1 s2)
                                               (<= s1 e2))
                                          (and (>= e1 s2)
                                               (<= e1 s2)))

                                      1
                                    0)))
                   (mapcar '(lambda (l) (s-split "," l))
                           (split-string input))))
#+end_src

#+RESULTS: overlap-count
: 4

The complexity doesn't change from the previous algorithm and is still ~O(n)~.

#+call: overlap-count(input-4)

#+RESULTS:
: 911

* Day 5

Example input (I cheated and changed the input shape to make it easier). The
input has each stack in top-down order on each line.

#+name: example-input-5
#+begin_example
N Z
D C M
P

move 1 from 2 to 1
move 3 from 1 to 3
move 2 from 2 to 1
move 1 from 1 to 2
#+end_example

Loading the puzzle input from a file, it was also modified.

#+name: input-5
#+call: input-loader("input5.txt") :results none

** Part 1
For the solution, we need to separate the input between the stacks and the
instruction list. We use a ~plist~ from ~elisp~ to make object access and
override values easier using key/value pairs.

We also treat the instruction removing fluff like the words /move/, /from/ and
/to/. Then we are left with two things, the list of instructions and the ~plist~
with the stacks ordered by number. We iterate over the instruction list,
repeating the moving (pop from one stack and push to another) and overriding
the stack list with the updated stacks after executing the instruction.

At the end we reduce the stacks to print just the head of each in a string.

#+name: crates-on-top
#+begin_src emacs-lisp :var input=example-input-5
(let* ((input (mapcar '(lambda (r) (delete "" (s-split ":" r)))
                      (s-split "::" (s-replace "\n" ":" input))))
       (stacks (-interleave (-iota (length (car input))) (mapcar '(lambda (s) (split-string s)) (car input))))
       (instructions (mapcar '(lambda (i)
                                (mapcar #'string-to-number
                                        (s-split ":"
                                                 (s-trim (s-replace-regexp
                                                          (rx (or " from " " to "))
                                                          ":"
                                                          (s-replace "move" "" i))))))
                                (cadr input))))
  (mapcar '(lambda (i) (let* ((o (- (cadr i) 1)) (d (- (caddr i) 1))
                              (oStack (plist-get stacks o)) (dStack (plist-get stacks d)))
                         (dotimes (n (car i))
                           (if (car oStack)
                               (progn (setq dStack (cons (car oStack) dStack))
                                      (setq oStack (cdr oStack)))))
                         (setq stacks (plist-put (plist-put stacks o oStack) d dStack))))
          instructions)
  (--reduce (format "%s%s" acc it) (mapcar '(lambda (i) (car (plist-get stacks i)))
                                           (-iota (length (car input))))))
#+end_src

#+RESULTS: crates-on-top
: CMZ

The complexity of the algorithm above depends on 3 factors, the size of the
stack list ~k~, the total number of elements on all stacks ~l~ and the size of
the instruction list ~n~. As we can see, the initial parsing works in ~O(l+n)~
as we just iterate over the stack elements and the instruction list.

Now for the simulation algorithm, it iterates over all instructions, and for
each iteration it runs 2 ~plist-get~ instructions and 2 ~plist-put~ instructions.
As those run over a list elementwise, they have complexity ~O(k)~ for ~plist-get~
and ~O(2k)~ for ~plist-put~. Each iteration also loops for a number of elements
that in the worst case could be the all the stackable elements (that is, ~l~).
So the overall complexity of each iteration is ~O(k+l)~ as constants don't
matter much for this analysis. The overall complexity of the simulation is then
~O(n*(k+l))~, as the last reduction step is less than the iteration and can be
simplified.

 #+call: crates-on-top(input-5)

 #+RESULTS:
 : FRDSQRRCD

** Part 2

For the second part, we can simplify the algorithm, as we don't need to loop
inside the instruction part, and we just need to /take/ an amount of elements
from one stack and just append to another.

#+name: crates-on-top-9001
#+begin_src emacs-lisp :var input=example-input-5
(let* ((input (mapcar '(lambda (r) (delete "" (s-split ":" r)))
                      (s-split "::" (s-replace "\n" ":" input))))
       (stacks (-interleave (-iota (length (car input))) (mapcar '(lambda (s) (split-string s)) (car input))))
       (instructions (mapcar '(lambda (i)
                                (mapcar #'string-to-number
                                        (s-split ":"
                                                 (s-trim (s-replace-regexp
                                                          (rx (or " from " " to "))
                                                          ":"
                                                          (s-replace "move" "" i))))))
                                (cadr input))))
  (mapcar '(lambda (i) (let* ((o (- (cadr i) 1)) (d (- (caddr i) 1))
                              (oStack (plist-get stacks o)) (dStack (plist-get stacks d)))
                         (setq dStack (-concat (-take (car i) oStack) dStack))
                         (setq oStack (-drop (car i) oStack))
                         (setq stacks (plist-put (plist-put stacks o oStack) d dStack))))
          instructions)
  (--reduce (format "%s%s" acc it) (mapcar '(lambda (i) (car (plist-get stacks i)))
                                           (-iota (length (car input))))))
#+end_src

#+RESULTS: crates-on-top-9001
: MCD

The complexity doesn't change much, as the ~-take/-drop/-concat~ functions run
over the list of elements with complexity ~O(l)~, with the ~plist-put/plist-get~
functions, the complexity is the same: ~O(n*(k+l))~

#+call: crates-on-top-9001(input-5)

#+RESULTS:
: HRFTQVWNN

* Day 6

Example input:
#+name: example-input-6
#+begin_example
zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw
#+end_example

Loading puzzle input:
#+name: input-6
#+call: input-loader("input6.txt") :results none

** Part 1
For this puzzle, we create a sliding window of length 4 over the input, then
we check if all 4 items are unique, if so, we use 0 as the marker, if not 1.
This generates a list of 1s and 0s for each window, we then iterate over it
adding up for each 1 we found, until we find a 0. Given that the amount of 1s
represents the number of sliding windows without 4 unique characters, and that
the sliding window steps 1 character at a time, when summing this to a base
value of 4, we get the number of characters that had to be consumed until we
found the marker.

#+name: chars-to-start-of-packet
#+begin_src emacs-lisp :var input=example-input-6
(let* ((index 4) (in (string-to-list input)))
  (-each-while (mapcar '(lambda (w) (if (< (length (-uniq w)) 4) 1 0))
                       (-partition-in-steps 4 1 in))
      (-compose #'not #'zerop)
    (lambda (_) (setq index (+ index 1))))
  index)
#+end_src

#+RESULTS:
: 11

The complexity of this algorithm depends on the first step that runs over all
sliding windows. As we must look at all windows of 4 elements, this means we
look at ~O(n-3)~ sliding windows (as the last 3 elements cant form a sliding
window of 4 elements). This means the overall complexity is ~O(n)~, as the next
loop goes over at most all sliding windows until we find a 0, and the ~length~
and ~uniq~ instructions have a constant complexity ~O(4)~.

#+call: chars-to-start-of-packet(input-6)

#+RESULTS:
: 1920

** Part 2

For the second part, nothing changes in the algorithm, except the size of the
sliding window and the value of the baseline used in the final sum.

#+name: chars-to-start-of-message
#+begin_src emacs-lisp :var input=example-input-6
(let* ((index 14) (in (string-to-list input)))
  (-each-while (mapcar '(lambda (w) (if (< (length (-uniq w)) 14) 1 0))
                       (-partition-in-steps 14 1 in))
      (-compose #'not #'zerop)
    (lambda (_) (setq index (+ index 1))))
  index)
#+end_src

#+RESULTS: chars-to-start-of-message
: 26

Its complexity also stays the same as no logic changes happened: ~O(n)~.
#+call: chars-to-start-of-message(input-6)

#+RESULTS:
: 2334

* Day 7
Example input:

#+name: example-input-7
#+begin_example
$ cd /
$ ls
dir a
14848514 b.txt
8504156 c.dat
dir d
$ cd a
$ ls
dir e
29116 f
2557 g
62596 h.lst
$ cd e
$ ls
584 i
$ cd ..
$ cd ..
$ cd d
$ ls
4060174 j
8033020 d.log
5626152 d.ext
7214296 k
#+end_example

#+name: input-7
#+call: input-loader("input7.txt") :results none

** Part 1

This is a more complex problem, and requires us to use a hashmap. To use strings
as keys, we must set the test function for the hashmap to use content/value
and not the object reference.
We iterate over the input. We separate by the ~$~ marker, bundling everything
until the next marker, this makes knowing the result of a command easier.
We then iterate over the list of command-output pairs, and use pattern-matching
to know if its a ~cd~ or an ~ls~. For ~cd~ we keep track of the directory path
from the root, and for ~ls~ we add to the hashmap with the current path as key
and the path for inner directories and size for inner files as value.

We then iterate over this hashmap, defining a recursive function to find the
size of a directory from its path. It is crucial to use the full path as the
identifier of the directory as there can be folders with the same name inside
different folders, /e.g./ ~/a/b/c/d~ and ~/a/e/d~ where ~d~ is the repeated
name, and its size must be different for each time it appears on the directory
tree.

After this, we filter out the entries that are bigger than 100000 and sum the
overall value to get the result.

#+name: dir-tree-deletable-count
#+begin_src emacs-lisp :var input=example-input-7
(let ((dir (make-hash-table :test 'equal)) (cDir '()))
  (-each (let ((tmp 0))
           (-partition-by '(lambda (i) (if (string= (car i) "$")
                                           (set 'tmp (random))
                                         tmp))
                          (mapcar (-partial #'s-split " ")
                                  (delete "" (s-split "\n" input)))))
    '(lambda (c) (pcase (car c)
                   (`("$" "cd" ,p)
                    (if (string= p "..")
                        (set 'cDir (cdr cDir))
                      (set 'cDir (cons p cDir))))
                   (`("$" "ls")
                    (puthash (mapconcat #'identity (reverse cDir) "/")
                             (mapcar '(lambda (n)
                                        (pcase n
                                          (`("dir" ,d)
                                           (mapconcat #'identity (reverse (cons d cDir)) "/"))
                                          (`(,s ,_)
                                           (string-to-number s))))
                                     (cdr c))
                             dir)
                    ))))
  (defun size (n)
    ""
    (pcase n
      ((pred numberp) n)
      ((pred stringp) (size (gethash n dir)))
      ((pred listp) (apply '+ (mapcar #'size n)))))
  (let (alist)
    (maphash '(lambda (key val) (push (cons key (size val)) alist)) dir)
    (apply #'+ (-filter (-partial #'>= 100000) (mapcar 'cdr alist)))))
#+end_src

#+RESULTS: dir-tree-deletable-count
: 95437

The complexity for this algorithm depends on the amount of folders overall ~n~
and the maximum depth of the tree ~k~.
Even though we have a recursion, we cannot have structures that are visited
twice on the recursion path as it wouldn't make sense. The complexity then
depends on visiting each folder with ~O(n)~. But, as the number of folders
also comes from the number of inputs, our complexity is actually ~O(k*n)~
because we build the folder path for each time we see the folder on the input
list. This could be better with some caching.

#+call: dir-tree-deletable-count(input-7)

#+RESULTS:
: 1391690

** Part 2

For the second part we just need to change the later logic. We also take the
chance to add a hash table for caching the sizes, and get the minimum directory
size that, when added to the unused space, is above the threshold set.

#+name: dir-tree-to-delete-size
#+begin_src emacs-lisp :var input=example-input-7
(let ((dir (make-hash-table :test 'equal)) (cDir '()))
  (-each (let ((tmp 0))
           (-partition-by '(lambda (i) (if (string= (car i) "$")
                                           (set 'tmp (random))
                                         tmp))
                          (mapcar (-partial #'s-split " ")
                                  (delete "" (s-split "\n" input)))))
    '(lambda (c) (pcase (car c)
                   (`("$" "cd" ,p)
                    (if (string= p "..")
                        (set 'cDir (cdr cDir))
                      (set 'cDir (cons p cDir))))
                   (`("$" "ls")
                    (puthash (mapconcat #'identity (reverse cDir) "/")
                             (mapcar '(lambda (n)
                                        (pcase n
                                          (`("dir" ,d)
                                           (mapconcat #'identity (reverse (cons d cDir)) "/"))
                                          (`(,s ,_)
                                           (string-to-number s))))
                                     (cdr c))
                             dir)
                    ))))
  (let ((dirSizes (make-hash-table :test 'equal)) (alist))
    (defun size (n)
      ""
      (pcase n
        ((pred numberp) n)
        ((pred stringp) (if (gethash n dirSizes)
                            (gethash n dirSizes)
                          (size (gethash n dir))))
        ((pred listp) (apply '+ (mapcar #'size n)))))

    (maphash '(lambda (key val)
                (puthash key (size val) dirSizes)
                (push (cons key (gethash key dirSizes)) alist))
             dir)
    (let ((unusedSpace (- 70000000 (gethash "/" dirSizes))))
      (- (seq-min (-filter (-partial #'<= 30000000) (mapcar '(lambda (s) (+ unusedSpace s)) (mapcar 'cdr alist)))) unusedSpace))))
#+end_src

#+RESULTS: dir-tree-to-delete-size
: 24933642

The complexity stays the same! ~O(k*n)~.

#+call: dir-tree-to-delete-size(input-7)

#+RESULTS:
: 5469168

* Day 8

#+name: example-input-8
#+begin_example
30373
25512
65332
33549
35390
#+end_example

#+name: input-8
#+call: input-loader("input8.txt") :results none

** Part 1

To solve this problem we count the number of visible trees in each direction
keeping track of what was the highest tree found so far. We repeat this in
all 4 directions (/right-left/, /left-right/, /up-down/, /down-up/). Then we
mark each tree that is visible in each direction combining them with a logical
~or~. We then count the number of trees overall.

#+name: count-visible-trees
#+begin_src emacs-lisp :var input=example-input-8
(defun transpose (m)
  (apply #'cl-mapcar #'list m))

(defun visible-trees-unidir (r)
  (let ((htree -1))
    (-map (lambda (tree) (if (> tree htree)
                             (progn
                               (set 'htree tree)
                               t)
                           nil))
          r)))
(defun not-null (e)
  (funcall (-compose #'not #'null) e))

(defun visible-trees-bidir (r)
  (-map (lambda (e) (-some #'not-null e))
        (-zip-lists
         (visible-trees r)
         (reverse (visible-trees (reverse r))))))

(let ((treemap (-map (lambda (r) (-map (-compose
                                        #'string-to-number
                                        (-partial #'format "%c"))
                                       (string-to-list r)))
                     (split-string input))))
  (-count #'identity
          (-flatten (-map (lambda (r) (-map (lambda (el) (-some #'not-null el))
                                            (-zip-lists (car r) (cadr r))))
                          (-zip-lists (-map #'visible-trees-bidir
                                            treemap)
                                      (transpose (-map #'visible-trees-bidir
                                                       (transpose treemap))))))))

#+end_src

#+RESULTS: count-visible-trees
: 21

The complexity of this algorithm is dependant on the size of the map, that is,
the number of rows(~r~) and columns(~c~). Overall, we just go through each
element of the map, a constant amount of times, which means the complexity
is ~O(r*c)~. We can simplify this to ~O(n^2)~  if we assume the map has square
coordinates.

#+call: count-visible-trees(input-8)

#+RESULTS:
: 1776

** Part 2

For the second part, we switch strategies, and go over each element of the treemap
and for each direction go over counting the ones that are smaller until we
find one with the same size (and count it).

#+name: scenic-score
#+begin_src emacs-lisp :var input=example-input-8
(defun tree-height (m c)
  (nth (cadr c) (nth (car c) m)))

(defun take-until (pred list)
  (let (reached oldReached)
    (-take-while (lambda (e) (progn
                               (set 'oldReached reached)
                               (set 'reached (funcall pred e))
                               (null oldReached)))
                   list)))
(let* ((treemap (-map (lambda (r) (-map (-compose
                                         #'string-to-number
                                         (-partial #'format "%c"))
                                        (string-to-list r)))
                      (split-string input)))
       (rlen (length treemap))
       (clen (length (car treemap)))
       (scores))
  (-each-indexed treemap
    (lambda (i r)
      (-each-indexed r
        (lambda (j e)
          (progn
            (add-to-list 'scores (-product (list (length (take-until (-compose (-partial (-flip #'>=) e) (-partial #'tree-height treemap)) ;; up
                                                                     (reverse (-zip-lists (-iota i) (-cycle (list j))))))
                                                 (length (take-until (-compose (-partial (-flip #'>=) e) (-partial #'tree-height treemap)) ;; down
                                                                     (-zip-lists (-iota (1- (- rlen i)) (1+ i) 1) (-cycle (list j)))))
                                                 (length (take-until (-compose (-partial (-flip #'>=) e) (-partial #'tree-height treemap)) ;; right
                                                                     (reverse (-zip-lists (-cycle (list i)) (-iota j)))))
                                                 (length (take-until (-compose (-partial (-flip #'>=) e) (-partial #'tree-height treemap)) ;; left
                                                                     (-zip-lists (-cycle (list i)) (-iota (1- (- clen j)) (1+ j) 1))))))))))))
  (-max scores))
#+end_src

#+RESULTS:
: 8

The complexity increases a lot. As we go over all 4 directions for each element
we end up doing ~O(r*(r*c))~ or ~O(c*(r*c))~, depending on what is bigger.
We can simplify that to ~O(n^3)~ if we assume the map has square coordinates.

#+call: scenic-score(input-8)

#+RESULTS:
: 234416
