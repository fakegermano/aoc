#+title: Elisp 10to20

#+name: input-file
#+begin_src elisp :var fname=""
(f-read fname)
#+end_src

* Day 11

#+name: example-11a
#+begin_example
125 17
#+end_example

#+name: simulate-blinks
#+begin_src elisp :var input=example-11a :var blinks=6
(defun split-digits-evenp (number)
  "splits the digits of a number in half if even else return nil"
  (when-let* ((digits (number-to-string number))
              (len (length digits))
              (_ (cl-evenp len))
              (mid (/ len 2)))
    (mapcar 'string-to-number (list (substring digits 0 mid)
                                    (substring digits mid len)))))
(defun blink-sim (stones blinks)
  "return len of arrengement after blinks"
  (let ((memo (make-hash-table)))
    (puthash 0 '(1) memo)
    (puthash 1 '(2024) memo)
    (dotimes (i blinks)
      (setq stones (apply 'append (mapcar (lambda (stone)
                                     (or (gethash stone memo)
                                         (puthash stone (if-let ((split (split-digits-evenp stone)))
                                                            split
                                                          (list (* stone 2024)))
                                                  memo)))
                                   stones))))
    (length stones)))

(let* ((stones (mapcar 'string-to-number (s-split " " (s-trim input)))))
  (blink-sim stones blinks))
#+end_src

#+RESULTS: simulate-blinks
: 22

#+call: simulate-blinks(input=input-file("input-11.txt"),blinks=25)

#+name: count-blink
#+begin_src elisp :var input=example-11a :var blinks=6
(defun split-digits-evenp (number)
  "splits the digits of a number in half if even else return nil"
  (when-let* ((digits (number-to-string number))
              (len (length digits))
              (_ (cl-evenp len))
              (mid (/ len 2)))
    (mapcar 'string-to-number (list (substring digits 0 mid)
                                    (substring digits mid len)))))

(defun blink-stone (stone blink-memo)
  "return the list of the result of blinking to the stone"
  (or (gethash stone blink-memo)
      (puthash stone (if-let ((split (split-digits-evenp stone)))
                         split
                       (list (* stone 2024)))
               blink-memo)))

(defun print-count (stones-count)
  "print stones count hash table"
  (let ((counts))
    (maphash (lambda (stone count)
               (push (list stone count) counts))
             stones-count)
    (message "%s" counts)))

(defun blink (stones blink-memo)
  "count number of stones after blinks"
  ;;(print-count stones)
  (let ((next-stones (make-hash-table)))
    (maphash (lambda (stone count)
               (mapc (lambda (next-stone)
                       (if-let ((next-count (gethash next-stone next-stones)))
                           (puthash next-stone (+ next-count count) next-stones)
                         (puthash next-stone count next-stones))
                       ;;(print-count next-stones)
                       )
                     (blink-stone stone blink-memo)))
             stones)
    next-stones))

(let* ((stones (mapcar 'string-to-number (s-split " " (s-trim input))))
       (stones-count (make-hash-table))
       (blink-memo (make-hash-table))
       (total 0))
  (mapc (lambda (stone)
          (if-let ((count (gethash stone stones-count)))
              (puthash stone (1+ count) stones-count)
            (puthash stone 1 stones-count)))
        stones)
  (puthash 0 '(1) blink-memo)
  (dotimes (i blinks)
    (setq stones-count (blink stones-count blink-memo)))
  (maphash (lambda (_ count) (setq total (+ total count))) stones-count)
  total)
#+end_src

#+RESULTS: count-blink
: 22

#+call: count-blink(blinks=25)

#+RESULTS:
: 55312

#+call: count-blink(input=input-file("input-11.txt"),blinks=25)


#+call: count-blink(input=input-file("input-11.txt"),blinks=75)



* Day 12

#+name: example-12a
#+begin_example
AAAA
BBCD
BBCC
EEEC
#+end_example

#+name: example-12b
#+begin_example
OOOOO
OXOXO
OOOOO
OXOXO
OOOOO
#+end_example

#+name: example-12c
#+begin_example
RRRRIICCFF
RRRRIICCCF
VVRRRCCFFF
VVRCCCJFFF
VVVVCJJCFE
VVIVCCJJEE
VVIIICJJEE
MIIIIIJJEE
MIIISIJEEE
MMMISSJEEE
#+end_example

#+name: calculate-price
#+begin_src elisp :var input=example-12a
(defun flood-fill-area-perimeter (farm seed)
  "uses flood-fill algorithm to find area and perimeter"
  (let* ((m (length farm))
         (n (length (aref farm 0)))
         (plant (aref (aref farm (car seed)) (cdr seed)))
         (stack)
         (area)
         (perimeter)
         (insidep (lambda (node)
                    (let ((inside (and (>= (car node) 0)
                                       (< (car node) m)
                                       (>= (cdr node) 0)
                                       (< (cdr node) n)
                                       (= (aref (aref farm (car node)) (cdr node)) plant))))
                      inside))))
    (push seed stack)
    (while-let ((node (pop stack)))
      (if (funcall insidep node)
          (unless (member node area)
            (push node area)
            (mapc (lambda (side)
                    (push (cons (+ (car node) (car side)) (+ (cdr node) (cdr side)))
                          stack))
                  '((-1 . 0) (1 . 0) (0 . -1) (0 . 1))))
        (push node perimeter)))
    ;;(message "%c %s %s" plant area perimeter)
    (list area perimeter)))

(let* ((farm (vconcat (mapcar 'string-to-vector (s-lines (s-trim input)))))
       (prices)
       (m (length farm))
       (n (length (aref farm 0)))
       (visited (make-vector (* m n) nil)))
  (dotimes (i m)
    (dotimes (j n)
      (when-let ((seed (cons i j))
                 (v (not (aref visited (+ (* i n) j))))
                 (price (flood-fill-area-perimeter farm seed))
                 (plant (aref (aref farm i) j)))
        ;; make sure to mark all nodes in region as visited to avoid double work
        (mapc (lambda (node)
                (aset visited (+ (* (car node) n) (cdr node)) t))
              (car price))
        (push (cons plant price) prices))))
  (apply '+ (mapcar (lambda (p)
                      (let* ((area (length (cadr p)))
                             (perimeter (length (caddr p)))
                             (plant (car p))
                             (price (* area perimeter)))
                        ;;(message "%c: [A:%d P:%d] %d" plant area perimeter price)
                        price))
                    prices)))
#+end_src

#+RESULTS:
: 140

#+call: calculate-price(input=example-12b)

#+RESULTS:
: 772


#+call: calculate-price(input=example-12c)

#+RESULTS:
: 1930

#+call: calculate-price(input=input-file("input-12.txt"))

#+name: calculate-price-discount
#+begin_src elisp :var input=example-12a
(defun map-as-list (map)
  "convert map to list with (key value) ordered by key"
  (let ((list-map))
    (maphash (lambda (key value)
               (push (list key value) list-map))
             map)
    (cl-sort list-map #'< :key #'car)
    list-map))

(defun map-coords (coords m n symfull symempty)
  "map the coordinate list as a matrix filling the i/j
with symfull at coordinate points and symempty otherwise"
  (let ((map (make-vector (* m n) symempty)))
    (mapc (lambda (c)
            (aset map (+ (* (car c) n) (cdr c)) symfull))
          coords)
    (mapconcat #'concat (seq-split map n) "\n")))

(defun compress-car (seq)
  "compresses a sorted sequence of cons by identifying increasing car values (when cdr is the same)"
  (let ((compressed))
    (dolist (c seq)
      ;; (message "%s %sx%s [%s+1=%s] [%s=%s]" compressed (car compressed) c (car (car compressed)) (car c) (cdr (car compressed)) (cdr c))
      (cond
       ((null compressed) nil)
       ((and (= (cdr (car compressed)) (cdr c))
             (= (car (car compressed)) (1- (car c))))
        (pop compressed)))
       (push c compressed))
    compressed))

(defun compress-cdr (seq)
  "compresses a sorted sequence of cons by identifying increasing cdr values (when car is the same)"
  (let ((compressed))
    (dolist (c seq)
      ;; (message "%s %sx%s [%s=%s] [%s+1=%s]" compressed (car compressed) c (car (car compressed)) (car c) (cdr (car compressed)) (cdr c))
      (cond
       ((null compressed) nil)
       ((and (= (car (car compressed)) (car c))
             (= (cdr (car compressed)) (1- (cdr c))))
        (pop compressed)))
      (push c compressed))
    compressed))

(defun less-car-cdr (u v)
  "compares if a cons is less then other looking at car first then at cdr"
  (if (= (car u) (car v))
      (< (cdr u) (cdr v))
    (< (car u) (car v))))

(defun less-cdr-car (u v)
  "compares if a cons is less then other looking at cdr first then at car"
  (if (= (cdr u) (cdr v))
      (< (car u) (car v))
    (< (cdr u) (cdr v))))

(defun flood-fill-area-perimeter (farm seed)
  "uses flood-fill algorithm to find area and perimeter"
  (let* ((m (length farm))
         (n (length (aref farm 0)))
         (plant (aref (aref farm (car seed)) (cdr seed)))
         (stack)
         (area)
         (perimeter-up)
         (perimeter-down)
         (perimeter-left)
         (perimeter-right)
         (perimeter)
         (insidep (lambda (node)
                    (let ((inside (and (>= (car node) 0)
                                       (< (car node) m)
                                       (>= (cdr node) 0)
                                       (< (cdr node) n)
                                       (= (aref (aref farm (car node)) (cdr node)) plant))))
                      inside))))
    (push seed stack)
    (while-let ((node (pop stack)))
      (unless (member node area)
        (push node area)
        (mapc (lambda (side)
                (let ((next (cons (+ (car node) (car side))
                                  (+ (cdr node) (cdr side)))))
                  (if (funcall insidep next)
                      (push next stack)
                    (pcase side
                      ('(-1 . 0) (push next perimeter-up))
                      ('(1 . 0) (push next perimeter-down))
                      ('(0 . -1) (push next perimeter-left))
                      ('(0 . 1) (push next perimeter-right))))))
              '((-1 . 0) (1 . 0) (0 . -1) (0 . 1)))))

    (cl-sort perimeter-up 'less-car-cdr)
    (cl-sort perimeter-down 'less-car-cdr)
    (cl-sort perimeter-left 'less-cdr-car)
    (cl-sort perimeter-right 'less-cdr-car)

    ;; (message "%s\n" (map-coords area m n plant ?.))
    (setq perimeter (append (compress-cdr perimeter-up)
                            (compress-cdr perimeter-down)
                            (compress-car perimeter-left)
                            (compress-car perimeter-right)))
    ;; (message "%s\n" (map-coords (mapcar (lambda (c) (cons (1+ (car c)) (1+ (cdr c)))) perimeter) (+ m 2) (+ n 2) ?# ?.))
    (list area perimeter)))

(let* ((farm (vconcat (mapcar 'string-to-vector (s-lines (s-trim input)))))
       (prices)
       (m (length farm))
       (n (length (aref farm 0)))
       (visited (make-vector (* m n) nil)))
  (dotimes (i m)
    (dotimes (j n)
      (when-let ((seed (cons i j))
                 (v (not (aref visited (+ (* i n) j))))
                 (price (flood-fill-area-perimeter farm seed))
                 (plant (aref (aref farm i) j)))
        ;; make sure to mark all nodes in region as visited to avoid double work
        (mapc (lambda (node)
                (aset visited (+ (* (car node) n) (cdr node)) t))
              (car price))
        (push (cons plant price) prices))))
  (apply '+ (mapcar (lambda (p)
                      (let* ((area (length (cadr p)))
                             (perimeter (length (caddr p)))
                             (plant (car p))
                             (price (* area perimeter)))
                        ;; (message "%c: [A:%d P:%d] %d" plant area perimeter price)
                        price))
                    prices)))
#+end_src

#+RESULTS: calculate-price-discount
: 80

#+call: calculate-price-discount(input=example-12b)

#+RESULTS:
: 436

#+name: example-12d
#+begin_example
EEEEE
EXXXX
EEEEE
EXXXX
EEEEE
#+end_example


#+call: calculate-price-discount(input=example-12d)

#+RESULTS:
: 236

#+name: example-12e
#+begin_example
AAAAAA
AAABBA
AAABBA
ABBAAA
ABBAAA
AAAAAA
#+end_example

#+call: calculate-price-discount(input=example-12e)

#+RESULTS:
: 368

#+call: calculate-price-discount(input=input-file("input-12.txt"))

#+RESULTS:
: 844132


* Day 13

#+name: example-13a
#+begin_example
Button A: X+94, Y+34
Button B: X+22, Y+67
Prize: X=8400, Y=5400

Button A: X+26, Y+66
Button B: X+67, Y+21
Prize: X=12748, Y=12176

Button A: X+17, Y+86
Button B: X+84, Y+37
Prize: X=7870, Y=6450

Button A: X+69, Y+23
Button B: X+27, Y+71
Prize: X=18641, Y=10279
#+end_example

#+name: fewest-tokens
#+begin_src elisp :var input=example-13a
(defun solve (machine)
  (let* ((A (car machine))
         (B (cadr machine))
         (P (caddr machine))
         (Ax (car A))
         (Ay (cdr A))
         (Bx (car B))
         (By (cdr B))
         (X (car P))
         (Y (cdr P))
         (b (/ (- (* Y Ax) (* X Ay)) (- (* Ax By) (* Ay Bx))))
         (a (/ (- X (* b Bx)) Ax)))
    (message "a: %d b: %d" a b)
    (when (and (= (+ (* a Ax) (* b Bx)) X)
               (= (+ (* a Ay) (* b By)) Y))
      (message "\twinnable!")
      (+ (* a 3) b))))

(let ((machines (mapcar (lambda (l)
                          (mapcar (lambda (g) (cons (string-to-number (car g)) (string-to-number (cadr g))))
                                  (list (cdr (s-match (rx "Button A: X+" (group (+ num)) ", Y+" (group (+ num))) (car l)))
                                        (cdr (s-match (rx "Button B: X+" (group (+ num)) ", Y+" (group (+ num))) (cadr l)))
                                        (cdr (s-match (rx "Prize: X=" (group (+ num)) ", Y=" (group (+ num))) (caddr l))))))
                        (mapcar 'butlast (seq-split (s-lines input) 4)))))
  (apply #'+ (seq-filter #'identity (mapcar 'solve machines))))
#+end_src

#+RESULTS:
: 480

#+call: fewest-tokens(input=input-file("input-13.txt"))

#+name: fewest-tokens-corrected
#+begin_src elisp :var input=example-13a
(defun solve (machine)
  (let* ((A (car machine))
         (B (cadr machine))
         (P (caddr machine))
         (Ax (car A))
         (Ay (cdr A))
         (Bx (car B))
         (By (cdr B))
         (X (+ (car P) 10000000000000))
         (Y (+ (cdr P) 10000000000000))
         (b (/ (- (* Y Ax) (* X Ay)) (- (* Ax By) (* Ay Bx))))
         (a (/ (- X (* b Bx)) Ax)))
    (message "a: %d b: %d" a b)
    (when (and (= (+ (* a Ax) (* b Bx)) X)
               (= (+ (* a Ay) (* b By)) Y))
      (message "\twinnable!")
      (+ (* a 3) b))))

(let ((machines (mapcar (lambda (l)
                          (mapcar (lambda (g) (cons (string-to-number (car g)) (string-to-number (cadr g))))
                                  (list (cdr (s-match (rx "Button A: X+" (group (+ num)) ", Y+" (group (+ num))) (car l)))
                                        (cdr (s-match (rx "Button B: X+" (group (+ num)) ", Y+" (group (+ num))) (cadr l)))
                                        (cdr (s-match (rx "Prize: X=" (group (+ num)) ", Y=" (group (+ num))) (caddr l))))))
                        (mapcar 'butlast (seq-split (s-lines input) 4)))))
  (apply #'+ (seq-filter #'identity (mapcar 'solve machines))))
#+end_src

#+RESULTS: fewest-tokens-corrected
: 875318608908

#+call: fewest-tokens-corrected(input=input-file("input-13.txt"))



* Day 14
#+name: example-14a
#+begin_example
p=0,4 v=3,-3
p=6,3 v=-1,-3
p=10,3 v=-1,2
p=2,0 v=2,-1
p=0,0 v=1,3
p=3,0 v=-2,-2
p=7,6 v=-1,-3
p=3,0 v=-1,-2
p=9,3 v=2,3
p=7,3 v=-1,2
p=2,4 v=2,-3
p=9,5 v=-3,-3
#+end_example

#+name: example-14b
#+begin_example
p=2,4 v=2,-3
#+end_example


#+name: robot-positions
#+begin_src elisp :var input=example-14a :var n=11 :var m=7 :var seconds=100
(defun print-positions (positions)
  "print positions in a map that is nxm"
  (let ((map (make-vector (* m n) nil)))
    (mapc (lambda (p)
            (let* ((pos (+ (* (cadr p) n) (car p)))
                   (curr (aref map pos)))
              (if curr
                  (aset map pos (1+ curr))
                (aset map pos 1))))
          positions)
    (mapconcat #'identity (mapcar (lambda (line) (mapconcat (lambda (p) (if p
                                                                            (number-to-string p)
                                                                          "."))
                                                            line ""))
                                  (seq-split map n))
               "\n")))

(defun get-quadrant (positions x y)
  "from list of positions make return only the ones on the quadrant (x1 to x2) and (y1 to y2)"
  (let ((quadrant))
    (mapc (lambda (p)
            (when (and (<= (car x) (car p) (cdr x))
                       (<= (car y) (cadr p) (cdr y)))
              (push p quadrant)))
          positions)
    quadrant))

(let* ((parsed (mapcar (lambda (l) (mapcar (lambda (v)
                                             (mapcar 'string-to-number
                                                     (s-split "," (cadr (s-split "=" v)))))
                                           (s-split " " l)))
                       (s-lines (s-trim input))))
       (final-positions (mapcar (lambda (robot)
                                  (let* ((p (car robot))
                                         (v (cadr robot))
                                         (x-after (% (+ (car p) (* (car v) seconds)) n))
                                         (y-after (% (+ (cadr p) (* (cadr v) seconds)) m)))
                                    (when (< x-after 0)
                                      (setq x-after (+ x-after n)))
                                    (when (< y-after 0)
                                      (setq y-after (+ y-after m)))
                                    (list x-after y-after)))
                                parsed))
       (q1 (get-quadrant final-positions (cons 0 (1- (/ n 2))) (cons 0 (1- (/ m 2)))))
       (q2 (get-quadrant final-positions (cons 0 (1- (/ n 2))) (cons (1+ (/ m 2)) m)))
       (q3 (get-quadrant final-positions (cons (1+ (/ n 2)) n) (cons 0 (1- (/ m 2)))))
       (q4 (get-quadrant final-positions (cons (1+ (/ n 2)) n) (cons (1+ (/ m 2)) m))))
  (message "initial:\n%s\n" (print-positions (mapcar 'car parsed)))
  (message "final:\n%s\n" (print-positions final-positions))
  (* (length q1) (length q2) (length q3) (length q4)))
#+end_src

#+RESULTS: robot-positions
: 12

#+call: robot-positions(input=example-14b,seconds=5)

#+RESULTS:
: 0

#+call:robot-positions(input=input-file("input-14.txt"),seconds=100,n=101,m=103)

#+RESULTS:
: 224554908

#+name: robot-easter-egg-hunt
#+begin_src elisp :var input=example-14a :var n=11 :var m=7 :var seconds=100
(defun print-positions (positions)
  "print positions in a map that is nxm"
  (let ((map (make-vector (* m n) nil)))
    (mapc (lambda (p)
            (let* ((pos (+ (* (cadr p) n) (car p)))
                   (curr (aref map pos)))
              (if curr
                  (aset map pos (1+ curr))
                (aset map pos 1))))
          positions)
    (mapconcat #'identity (mapcar (lambda (line) (mapconcat (lambda (p) (if p
                                                                            (number-to-string p)
                                                                          "."))
                                                            line ""))
                                  (seq-split map n))
               "\n")))

(let* ((parsed (mapcar (lambda (l) (mapcar (lambda (v)
                                             (mapcar 'string-to-number
                                                     (s-split "," (cadr (s-split "=" v)))))
                                           (s-split " " l)))
                       (s-lines (s-trim input))))
       (next parsed)
       (possible-tree)
       (i 0)
       (min-entropy '(-1 . 1.0)))

  ;;(message "initial:\n%s\n" (print-positions (mapcar 'car parsed)))
  (while (null possible-tree)
    (setq i (1+ i))
    (setq next (mapcar (lambda (robot)
                         (let* ((p (car robot))
                                (v (cadr robot))
                                (x-after (% (+ (car p) (* (car v) 1)) n))
                                (y-after (% (+ (cadr p) (* (cadr v) 1)) m)))
                           (when (< x-after 0)
                             (setq x-after (+ x-after n)))
                           (when (< y-after 0)
                             (setq y-after (+ y-after m)))
                           (list (list x-after y-after) v)))
                       next))
        (when (= (length next) (length (seq-uniq (mapcar (lambda (p) (+ (* (cadr p) n) (car p))) (mapcar 'car next)))))
      (setq min-entropy i)
      (setq possible-tree (mapcar 'car next))))
  (message "tree:\n%s\n" (print-positions possible-tree))
  min-entropy)
#+end_src

#+RESULTS: robot-easter-egg-hunt
: 0

#+call: robot-easter-egg-hunt(input=input-file("input-14.txt"),n=101,m=103)

#+RESULTS:
: 6643


* Day 15

#+name: example-15a
#+begin_example
##########
#..O..O.O#
#......O.#
#.OO..O.O#
#..O@..O.#
#O#..O...#
#O..O..O.#
#.OO.O.OO#
#....O...#
##########

<vv>^<v^>v>^vv^v>v<>v^v<v<^vv<<<^><<><>>v<vvv<>^v^>^<<<><<v<<<v^vv^v>^
vvv<<^>^v^^><<>>><>^<<><^vv^^<>vvv<>><^^v>^>vv<>v<<<<v<^v>^<^^>>>^<v<v
><>vv>v^v^<>><>>>><^^>vv>v<^^^>>v^v^<^^>v^^>v^<^v>v<>>v^v^<v>v^^<^^vv<
<<v<^>>^^^^>>>v^<>vvv^><v<<<>^^^vv^<vvv>^>v<^^^^v<>^>vvvv><>>v^<<^^^^^
^><^><>>><>^^<<^^v>>><^<v>^<vv>>v>>>^v><>^v><<<<v>>v<v<v>vvv>^<><<>^><
^>><>^v<><^vvv<^^<><v<<<<<><^v<<<><<<^^<v<^^^><^>>^<v^><<<^>>^v<v^v<v^
>^>>^v>vv>^<<^v<>><<><<v<<v><>v<^vv<<<>^^v^>^^>>><<^v>>v^v><^^>>^<>vv^
<><^^>^^^<><vvvvv^v<v<<>^v<v>v<<^><<><<><<<^^<<<^<<>><<><^^^>^^<>^>v<>
^^>vv<^v^v<vv>^<><v<^v>^^^>>>^^vvv^>vvv<>>>^<^>>>>>^<<^v>^vvv<>^<><<v>
v^^>>><<^^<>>^v^<v^vv<>v^<<>^<^v^v><^<<<><<^<v><v<>vv>>v><v^<vv<>v^<<^
#+end_example

#+name: example-15b
#+begin_example
########
#..O.O.#
##@.O..#
#...O..#
#.#.O..#
#...O..#
#......#
########

<^^>>>vv<v>>v<<
#+end_example

#+name: move-push-and-gps
#+begin_src elisp :var input=example-15b
(defun print-map (map m n)
  "prints the map as matrix"
  (mapconcat 'identity (mapcar 'concat (seq-split map n)) "\n"))

(defun move-and-push (d map p m n)
  "return the new position after moving in the direction
pushes all boxes that can be pushed if any"
  (let ((move)
        (la 0)
        (boxes))
    (pcase d
      (?^
       (setq move (* -1 n)))
      (?v
       (setq move n))
      (?<
       (setq move -1))
      (?>
       (setq move 1)))
    (setq la (+ p move))
    (pcase (aref map la)
     (?# p)
     (?O
      (push la boxes)
      (setq la (+ la move))
      (while (= (aref map la) ?O)
        (push la boxes)
        (setq la (+ la move)))
      (if (= (aref map la) ?.)
           (progn
             (while-let ((box (pop boxes)))
               (aset map box ?.)
               (aset map la ?O)
               (setq la box))
             la)
         p))
     (?. la))))

(let* ((parsed (s-split "||" (s-replace "\n" "|" (s-trim input))))
       (map (vconcat (mapcar 'string-to-vector (s-split "|" (car parsed)))))
       (m (length map))
       (n (length (aref map 0)))
       (flatmap (string-to-vector (mapconcat #'identity map "")))
       (pos (seq-position flatmap ?@))
       (movements (string-to-list (s-replace "|" "" (cadr parsed)))))
  (while-let ((dir (pop movements)))
    (aset flatmap pos ?.)
    (setq pos (move-and-push dir flatmap pos m n))
    (aset flatmap pos ?@))
  (message "%s" (print-map flatmap m n))
  (apply #'+ (mapcar (lambda (p) (+ (* (/ p n) 100) (% p n)))
                     (seq-positions flatmap ?O))))
#+end_src

#+call: move-push-and-gps(input=example-15a)

#+RESULTS:
: 10092

#+call: move-push-and-gps(input=input-file("input-15.txt"))

#+name: example-15c
#+begin_example
#######
#...#.#
#.....#
#..OO@#
#..O..#
#.....#
#######

<vv<<^^<<^^
#+end_example


#+name: move-push-and-gps-wide
#+begin_src elisp :var input=example-15c
(defun print-wide-map (map m n)
  "prints the map as matrix"
  (mapconcat 'identity (mapcar 'concat (seq-split map n)) "\n"))

(defun push-horizontal (map move p)
  "push boxes horizontally following move"
  (let ((la (+ p move))
        (boxes))
    (pcase (aref map la)
      (?. la)
      (?# p)
      (_
       (push la boxes)
       (setq la (+ p move))
       (while (or (= (aref map la) ?\[)
                  (= (aref map la) ?\]))
         (push la boxes)
         (setq la (+ la move)))

       (if (= (aref map la) ?.)
           (progn
             (while-let ((box (pop boxes)))
               (aset map la (aref map box))
               (aset map box ?.)
               (setq la box))
             la)
         p)))))

(defun push-vertical (map move p)
  "push boxes vertically following move"
  (let ((la)
        (boxes))
    (pcase (aref map (+ p move))
      (?. (+ p move))
      (?# p)
      (_
       (when (= (aref map (+ p move)) ?\[)
         (push (cons (+ p move) (+ p move 1)) la))
       (when (= (aref map (+ p move)) ?\])
         (push (cons (+ p move -1) (+ p move)) la))

       (while-let ((boxla (pop la))
                   (lla (aref map (car boxla)))
                   (rla (aref map (cdr boxla))))
         (cond
          ((and (= lla ?\[) (= rla ?\]))
           (unless (member boxla boxes)
             (push (cons (+ (car boxla) move) (+ (cdr boxla) move)) la)
             (push boxla boxes)))
          ((or (= lla ?\]) (= rla ?\[))
           (when (= lla ?\])
             (unless (member (cons (1- (car boxla)) (car boxla)) boxes)
               (push (cons (+ (car boxla) move -1) (+ (car boxla) move)) la)
               (push (cons (1- (car boxla)) (car boxla)) boxes)))
           (when (= rla ?\[)
             (unless (member (cons (cdr boxla) (1+ (cdr boxla))) boxes)
               (push (cons (+ (cdr boxla) move) (+ (cdr boxla) move 1)) la)
               (push (cons (cdr boxla) (1+ (cdr boxla))) boxes))))))

       (mapc (lambda (b)
               (push (+ (car b) move) la)
               (push (+ (cdr b) move) la))
             boxes)
       (if (seq-every-p (lambda (c) (not (= (aref map c) ?#))) la)
           (progn
             (if (< move 0)
                 ;; sort smalest first
                 (cl-sort boxes #'< :key #'car)
               ;; sort largest first
               (cl-sort boxes #'> :key #'car))
             (while-let ((box (pop boxes))
                         (current (cons (aref map (car box)) (aref map (cdr box))))
                         (ahead (cons (aref map (+ (car box) move)) (aref map (+ (cdr box) move)))))
               (aset map (+ (car box) move) (car current))
               (aset map (+ (cdr box) move) (cdr current))
               (aset map (car box) (car ahead))
               (aset map (cdr box) (cdr ahead)))
             (+ p move))
         p)
       ))))

(defun move-and-push-wide (d map p m n)
  "return the new position after moving in the direction
pushes all boxes that can be pushed if any"
  (pcase d
    (?^
     (push-vertical map (* -1 n) p))
    (?v
     (push-vertical map n p))
    (?<
     (push-horizontal map -1 p))
    (?>
     (push-horizontal map 1 p))))

(let* ((parsed (s-split "||" (s-replace "\n" "|" (s-trim input))))
       (map (vconcat (mapcar (lambda (s) (string-to-vector (s-replace-all
                                                            '(("#" . "##")
                                                              ("O" . "[]")
                                                              ("." . "..")
                                                              ("@" . "@."))
                                                            s)))
                             (s-split "|" (car parsed)))))
       (m (length map))
       (n (length (aref map 0)))
       (flatmap (string-to-vector (mapconcat #'identity map "")))
       (pos (cl-position ?@ flatmap))
       (movements (string-to-list (s-replace "|" "" (cadr parsed)))))

  ;; (with-output-to-temp-buffer "*move-push-wide*"
  ;;   (print! "%s\n" (print-wide-map flatmap m n))
    (while-let ((dir (pop movements)))
      (aset flatmap pos ?.)
      (setq pos (move-and-push-wide dir flatmap pos m n))
      (aset flatmap pos ?@)

      ;; (print! "%c\n%s\n" dir (print-wide-map flatmap m n)))
    )

    (message "%s" (print-wide-map flatmap m n))
    (apply #'+ (mapcar (lambda (p) (+ (* (/ p n) 100) (% p n)))
                       (seq-positions flatmap ?\[)))
  )
#+end_src

#+RESULTS: move-push-and-gps-wide
: 618

#+call: move-push-and-gps-wide(input=example-15a)

#+RESULTS:
: 9021

#+call: move-push-and-gps-wide(input=example-15b)

#+RESULTS:
: 1751

#+name: example-15d
#+begin_example
#########
#.OOOO..#
#.O....O#
#..O.OO.#
#@OO..O.#
#..OO..O#
#O.OO...#
#..OO..##
#..O..O.#
#.......#
#.......#
#########

>>vvvv>>v>>>>^^^^^<^^<<v
#+end_example

#+call: move-push-and-gps-wide(input=example-15d)

#+RESULTS:
: 10375


#+call: move-push-and-gps-wide(input=input-file("input-15.txt"))


* Day 16

#+name: example-16a
#+begin_example
###############
#.......#....E#
#.#.###.#.###.#
#.....#.#...#.#
#.###.#####.#.#
#.#.#.......#.#
#.#.#####.###.#
#...........#.#
###.#.#####.#.#
#...#.....#.#.#
#.#.#.###.#.#.#
#.....#...#.#.#
#.###.#.#.#.#.#
#S..#.....#...#
###############
#+end_example

#+name: example-16b
#+begin_example
#################
#...#...#...#..E#
#.#.#.#.#.#.#.#.#
#.#.#.#...#...#.#
#.#.#.#.###.#.#.#
#...#.#.#.....#.#
#.#.#.#.#.#####.#
#.#...#.#.#.....#
#.#.#####.#.###.#
#.#.#.......#...#
#.#.###.#####.###
#.#.#...#.....#.#
#.#.#.#####.###.#
#.#.#.........#.#
#.#.#.#########.#
#S#.............#
#################
#+end_example

#+name: reindeer-maze-score
#+begin_src elisp :var input=example-16a
(defun print-map (map n)
  "prints the map as matrix"
  (mapconcat 'identity (mapcar 'concat (seq-split map n)) "\n"))

(let* ((map (vconcat (mapcar 'string-to-vector (s-lines (s-trim input)))))
       (n (length (aref map 0)))
       (flatmap (string-to-vector (mapconcat #'identity map "")))
       (source (cl-position ?S flatmap))
       (dest (cl-position ?E flatmap))
       (pqueue)
       (moves (list (* -1 n) -1 n 1)) ;; up, left, down and right
       (g-scores (make-vector (* (length flatmap) 4) nil))
       ;; (f-scores (make-vector (length flatmap) nil))
       (previous (make-vector (* (length flatmap) 4) nil))
       ;; visited needs to consider the directions
       (visited (make-vector (* (length flatmap) 4) nil)))

  (aset g-scores (+ (* source 4) 3) 0)

  ;;(message "%s\n" (print-map flatmap n))
  (push (+ (* source 4) 3) pqueue)

  (while-let ((nodeposdir (pop pqueue))
              (pos (/ nodeposdir 4))
              (dir (% nodeposdir 4))
              (move (nth dir moves))
              (_ (not (= pos dest))))
    (aset visited nodeposdir t)

    ;; forward
    (when-let ((neigh (+ pos move))
               (neighposdir (+ (* neigh 4) dir))
               (notwall (not (= (aref flatmap neigh) ?#)))
               (notvisited (null (aref visited neighposdir))))

      (unless (memq neighposdir pqueue)
        (push neighposdir pqueue))

      (when-let ((tg-score (+ (aref g-scores nodeposdir) 1))
                 (_ (or (null (aref g-scores neighposdir)) ;; nil g-score -> infinite
                        (<= tg-score (aref g-scores neighposdir)))))
        (aset previous neighposdir nodeposdir)
        (aset g-scores neighposdir tg-score)))

    ;; turn left
    (when-let ((ndir (% (1+ dir) 4))
               (neigh (+ pos (nth ndir moves)))
               (neighposdir (+ (* neigh 4) ndir))
               (notwall (not (= (aref flatmap neigh) ?#)))
               (notvisited (null (aref visited neighposdir))))
      (unless (memq neighposdir pqueue)
        (push neighposdir pqueue))

      (when-let ((tg-score (+ (aref g-scores nodeposdir) 1001))
                 (_ (or (null (aref g-scores neighposdir)) ;; nil g-score -> infinite
                        (<= tg-score (aref g-scores neighposdir)))))
        (aset previous neighposdir nodeposdir)
        (aset g-scores neighposdir tg-score))
      )

    ;; turn right
    (when-let ((ndir (if (< (% (1- dir) 4) 0)
                         (+ 4 (% (1- dir) 4))
                       (% (1- dir) 4)))
               (neigh (+ pos (nth ndir moves)))
               (neighposdir (+ (* neigh 4) ndir))
               (notwall (not (= (aref flatmap neigh) ?#)))
               (notvisited (null (aref visited neighposdir))))
      (unless (memq neighposdir pqueue)
        (push neighposdir pqueue))

      (when-let ((tg-score (+ (aref g-scores nodeposdir) 1001))
                 (_ (or (null (aref g-scores neighposdir)) ;; nil g-score -> infinite
                        (<= tg-score (aref g-scores neighposdir)))))
        (aset previous neighposdir nodeposdir)
        (aset g-scores neighposdir tg-score))
      )
    ;; sort queue according with lowest g-score first
    (cl-sort pqueue (lambda (u v) (< (aref g-scores u)
                                     (aref g-scores v))))
    ;; (message "%s" (mapcar (lambda (p) (list (cons (/ (/ p 4) n) (% (/ p 4) n))
    ;;                                         (nth (% p 4) moves)
    ;;                                         (aref g-scores p)))
    ;;                       pqueue))
    )

  ;; helper to visualize map
  (let* ((destscores (mapcar (lambda (dir) (or (aref g-scores (+ (* dest 4) dir))
                                               most-positive-fixnum))
                             (number-sequence 0 3)))
         (score (seq-min destscores))
         (dir (cl-position score destscores))
         (pos (aref previous (+ (* dest 4) dir))))
    (while (not (= pos (+ (* source 4) 3)))
      (setq dir (% pos 4))
      (cond
       ;; up
       ((= dir 0) (aset flatmap (/ pos 4) ?^))
       ((= dir 1) (aset flatmap (/ pos 4) ?<))
       ((= dir 2) (aset flatmap (/ pos 4) ?v))
       (t (aset flatmap (/ pos 4) ?>)))
      (setq pos (aref previous pos)))

    (message "%s\n" (print-map flatmap n))
    score))
#+end_src

#+RESULTS: reindeer-maze-score
: 7036

#+call: reindeer-maze-score(input=example-16b)

#+RESULTS:
: 11048

#+name: example-16c
#+begin_example
###############
#.#.#...#.#...#
#.#.#.#####.#.#
#.#...#.....#.#
#######.#####.#
#.#.....#...#.#
#E#.#####.#.#.#
#.....#...#...#
#####.#.#.#.#.#
#...#.#.#...#.#
#.#.#.#.#.#.#.#
#.#.#...#.....#
###.#.###.#.#.#
#.......##.#S.#
###############
#+end_example

#+call: reindeer-maze-score(input=example-16c)

#+RESULTS:
: 9028

#+call: reindeer-maze-score(input=input-file("input-16.txt"))

#+name: reindeer-maze-count-paths
#+begin_src elisp :var input=example-16a
(defun print-map (map n)
  "prints the map as matrix"
  (mapconcat 'identity (mapcar 'concat (seq-split map n)) "\n"))

(let* ((map (vconcat (mapcar 'string-to-vector (s-lines (s-trim input)))))
       (n (length (aref map 0)))
       (flatmap (string-to-vector (mapconcat #'identity map "")))
       (source (cl-position ?S flatmap))
       (dest (cl-position ?E flatmap))
       (pqueue)
       (moves (list (* -1 n) -1 n 1)) ;; up, left, down and right
       (g-scores (make-vector (* (length flatmap) 4) nil))
       ;; (f-scores (make-vector (length flatmap) nil))
       (previous (make-vector (* (length flatmap) 4) nil))
       ;; visited needs to consider the directions
       (visited (make-vector (* (length flatmap) 4) nil)))

  (aset g-scores (+ (* source 4) 3) 0)

  ;;(message "%s\n" (print-map flatmap n))
  (push (+ (* source 4) 3) pqueue)

  (while-let ((nodeposdir (pop pqueue))
              (pos (/ nodeposdir 4))
              (dir (% nodeposdir 4))
              (move (nth dir moves))
              (_ (not (= pos dest))))
    (aset visited nodeposdir t)

    ;; forward
    (when-let ((neigh (+ pos move))
               (neighposdir (+ (* neigh 4) dir))
               (notwall (not (= (aref flatmap neigh) ?#)))
               (notvisited (null (aref visited neighposdir))))

      (unless (memq neighposdir pqueue)
        (push neighposdir pqueue))

      (when-let ((tg-score (+ (aref g-scores nodeposdir) 1))
                 (neighscore (or (aref g-scores neighposdir)
                                 most-positive-fixnum))
                 (_ (<= tg-score neighscore)))
        (when (< tg-score neighscore)
          (aset previous neighposdir (list nodeposdir)))
        (when (= tg-score neighscore)
          (unless (memq nodeposdir (aref previous neighposdir))
            (aset previous neighposdir (cons nodeposdir (aref previous neighposdir)))))
        (aset g-scores neighposdir tg-score)))

    ;; turn left
    (when-let ((ndir (% (1+ dir) 4))
               (neigh (+ pos (nth ndir moves)))
               (neighposdir (+ (* neigh 4) ndir))
               (notwall (not (= (aref flatmap neigh) ?#)))
               (notvisited (null (aref visited neighposdir))))
      (unless (memq neighposdir pqueue)
        (push neighposdir pqueue))

      (when-let ((tg-score (+ (aref g-scores nodeposdir) 1001))
                 (neighscore (or (aref g-scores neighposdir)
                                 most-positive-fixnum))
                 (_ (<= tg-score neighscore)))
        (when (< tg-score neighscore)
          (aset previous neighposdir (list nodeposdir)))
        (when (= tg-score neighscore)
          (unless (memq nodeposdir (aref previous neighposdir))
            (aset previous neighposdir (cons nodeposdir (aref previous neighposdir)))))
        (aset g-scores neighposdir tg-score))
      )

    ;; turn right
    (when-let ((ndir (if (< (% (1- dir) 4) 0)
                         (+ 4 (% (1- dir) 4))
                       (% (1- dir) 4)))
               (neigh (+ pos (nth ndir moves)))
               (neighposdir (+ (* neigh 4) ndir))
               (notwall (not (= (aref flatmap neigh) ?#)))
               (notvisited (null (aref visited neighposdir))))
      (unless (memq neighposdir pqueue)
        (push neighposdir pqueue))

      (when-let ((tg-score (+ (aref g-scores nodeposdir) 1001))
                 (neighscore (or (aref g-scores neighposdir)
                                 most-positive-fixnum))
                 (_ (<= tg-score neighscore)))
        (when (< tg-score neighscore)
          (aset previous neighposdir (list nodeposdir)))
        (when (= tg-score neighscore)
          (unless (memq nodeposdir (aref previous neighposdir))
            (aset previous neighposdir (cons nodeposdir (aref previous neighposdir)))))
        (aset g-scores neighposdir tg-score))
      )
    ;; sort queue according with lowest g-score first
    (cl-sort pqueue (lambda (u v) (< (aref g-scores u)
                                     (aref g-scores v))))
    ;; (message "%s" (mapcar (lambda (p) (list (cons (/ (/ p 4) n) (% (/ p 4) n))
    ;;                                         (nth (% p 4) moves)
    ;;                                         (aref g-scores p)))
    ;;                       pqueue))
    )

  ;; helper to visualize map
  (let* ((stack)
         (scores (list (or (aref g-scores (* dest 4))
                           most-positive-fixnum)
                       (or (aref g-scores (+ (* dest 4) 1))
                           most-positive-fixnum)
                       (or (aref g-scores (+ (* dest 4) 2))
                           most-positive-fixnum)
                       (or (aref g-scores (+ (* dest 4) 3))
                           most-positive-fixnum)))
         (score (seq-min scores))
         (dir (cl-position score scores))
         (path))
    (mapc (lambda (p) (push p stack))
          (aref previous (+ (* dest 4) dir)))
    (push dest path)
    (while-let ((prev (pop stack))
                (pos (/ prev 4))
                (dir (% prev 4)))
      (unless (memq pos path)
        ;; (message "%s %d %d" (cons (/ pos n) (% pos n)) dir (aref g-scores prev))
        (push pos path))
      (cond
       ((= dir 0) (aset flatmap pos ?^))
       ((= dir 1) (aset flatmap pos ?<))
       ((= dir 2) (aset flatmap pos ?v))
       (t (aset flatmap pos ?>)))

      (mapc (lambda (p) (push p stack))
            (aref previous prev)))

    ;; (message "%s\n" (print-map flatmap n))
    ;; (message "%s" (mapcar (lambda (p) (cons (/ p n) (% p n))) path))
    (length path)))
#+end_src

#+RESULTS: reindeer-maze-count-paths
: 45

#+call: reindeer-maze-count-paths(input=example-16b)

#+RESULTS:
: 64


#+call: reindeer-maze-count-paths(input=example-16c)

#+RESULTS:
: 29

#+call: reindeer-maze-count-paths(input=input-file("input-16.txt"))

#+RESULTS:
: 449


* Day 17

#+name: example-17a
#+begin_example
Register A: 729
Register B: 0
Register C: 0

Program: 0,1,5,4,3,0
#+end_example

#+name: program-output
#+begin_src elisp :var input=example-17a
(defun combo-op (op reg-a reg-b reg-c)
  "returns the combo operator value of op"
  (aref (vector 0 1 2 3 reg-a reg-b reg-c t) op))

(let* ((parsed (mapcar (lambda (s) (s-split "," (car (reverse (s-split " " s))))) (s-lines (s-replace "\n\n" "\n" (s-trim input)))))
       (reg-a (string-to-number (caar parsed)))
       (reg-b (string-to-number (caadr parsed)))
       (reg-c (string-to-number (caaddr parsed)))
       (program (vconcat (mapcar 'vconcat (seq-split (mapcar 'string-to-number (cadddr parsed)) 2))))
       (outputs)
       (ic 0))
  (while-let ((_ (< ic (length program)))
              (inst (aref program ic))
              (code (aref inst 0))
              (op (aref inst 1))
              (c-op (combo-op op reg-a reg-b reg-c))
              (inc 1))

    (message "%d %d %d" reg-a reg-b reg-c)
    (message "%d %d %s" code op c-op)
    (pcase code
      (0 (message "adv")
         (setq reg-a (ash reg-a (* -1 c-op))))
      (1 (message "bxl")
         (setq reg-b (logxor reg-b op)))
      (2 (message "bst")
         (setq reg-b (logand c-op 7)))
      (3 (message "jnz")
         (unless (zerop reg-a)
           (setq inc 0)
           (setq ic op)))
      (4 (message "bxc")
         (setq reg-b (logxor reg-b reg-c)))
      (5 (message "out")
         (push (logand c-op 7) outputs))
      (6 (message "bdv")
         (setq reg-b (ash reg-a (* -1 c-op))))
      (7 (message "cdv")
         (setq reg-c (ash reg-a (* -1 c-op)))))
    (message "%d %d" ic inc)
    (setq ic (+ ic inc))
    )
  (message "%d %d %d %s" reg-a reg-b reg-c program)
  (s-join "," (mapcar 'number-to-string (reverse outputs))))
#+end_src

#+RESULTS: program-output
: 4,6,3,5,6,3,5,2,1,0

#+call: program-output(input=input-file("input-17.txt"))

#+RESULTS:
: 2,3,4,7,5,7,3,0,7

#+name: example-17b
#+begin_example
Register A: 2024
Register B: 0
Register C: 0

Program: 0,3,5,4,3,0
#+end_example

This is really hard. we can probably reverse engineer from the reverse program output
but requires a lot of memory and trial and error and building the tables for which
the output is the expected after the iteration.

we also need to remember all possible candidates as it could be that a future one doesnt give us the desired
output so we need to backtrack.


#+begin_src elisp :var input=example-17b
(defun combo-op (op reg-a reg-b reg-c)
  "returns the combo operator value of op"
  (aref (vector 0 1 2 3 reg-a reg-b reg-c 8) op))

(defun min-as-match-output (program as output)
  "retun minimum of as that produce expected output when run in program
assumes as are ordered"
  (let ((ic 0)
        (ra (vconcat as))
        (rb (make-vector (length as) 0))
        (rc (make-vector (length as) 0))
        (min-ras)
        (outputs (make-vector (length as) 8))) ;; 8 is just to fill with an invalid number
    (dotimes (i (length ra))
      (setq ic 0)
      (while-let ((_ (< ic (length program)))
                  (inst (aref program ic))
                  (code (aref inst 0))
                  (op (aref inst 1))
                  (c-op (combo-op op (aref ra i) (aref rb i) (aref rc i)))
                  (inc 1))
        (pcase code
          (0
           (aset ra i (ash (aref ra i) (* -1 c-op))))
          (1
           (aset rb i (logxor (aref rb i) op)))
          (2
           (aset rb i (logand c-op 7) op))
          (3
           ;; do nothing, we want one single iteration
           (when (= (aref outputs i) output)
             (push (aref ra i) min-ras)))
          (4
           (aset rb i (logand (aref rb i) (aref rc i))))
          (5
           (aset outputs i (logand c-op 7)))
          (6
           (aset rb i (ash (aref ra i) (* -1 c-op))))
          (7
           (aset rc i (ash (aref ra i) (* -1 c-op)))))
        (message "\t\ti:%d ra:%d rb:%d rc:%d" i (aref ra i) (aref rb i) (aref rc i))
        (setq ic (+ ic inc))))

    min-ras))


(let* ((parsed (mapcar (lambda (s) (s-split "," (car (reverse (s-split " " s))))) (s-lines (s-replace "\n\n" "\n" (s-trim input)))))
       (raw-program (mapcar 'string-to-number (cadddr parsed)))
       (program (vconcat (mapcar 'vconcat (seq-split raw-program 2))))
       (as '(1 2 3 4 5 6 7))
       (a))
  (setq raw-program (reverse raw-program))
  (message "%s" raw-program)
  (while-let ((output (pop raw-program)))
    (while-let (()))
    (let ((min-as (min-as-match-output program as output)))
      (message "%s" min-as)
      (mapc (lambda (ma) (push (+ (ash ma 3) a))) min-as)

      (setq as (mapcar (lambda (i) (+ (ash min-a 3) i)) '(0 1 2 3 4 5 6 7)))))
  a)
#+end_src


* Day 18

#+name: example-18a
#+begin_example
5,4
4,2
4,5
3,0
2,1
6,3
2,4
1,5
0,6
3,3
2,6
5,1
1,2
5,5
2,5
6,5
1,4
0,4
6,4
1,1
6,1
1,0
0,5
1,6
2,0
#+end_example

#+name: shortest-path-count
#+begin_src elisp :var input=example-18a :var n=7 :var bytes=12
(defun print-map (map n)
  "prints the map as matrix"
  (mapconcat 'identity (mapcar 'concat (seq-split map n)) "\n"))

(defun neighbors (pos map visited n)
  "get list of valid (non-wall) neighbors"
  (let ((neighs))
    (mapc (lambda (move) (when-let ((y (+ (/ pos n) (car move)))
                                    (x (+ (% pos n) (cdr move)))
                                    (node (+ (* y n) x))
                                    (_ (and (< -1 x n)
                                            (< -1 y n)
                                            (not (= (aref map node) ?#))
                                            (not (aref visited node)))))
                           (push node neighs)))
          '((-1 . 0) (1 . 0) (0 . -1) (0 . 1)))
    neighs))

(let* ((parsed (vconcat (mapcar (lambda (l) (vconcat (reverse (mapcar 'string-to-number
                                                                      (s-split "," l)))))
                                (s-lines (s-trim input)))))
       (flatmap (make-vector (* n n) ?.))
       (source 0)
       (sink (1- (length flatmap)))
       (visited (make-vector (* n n) nil))
       (costs (make-vector (* n n) nil))
       (previous (make-vector (* n n) nil))
       (pqueue))
  (dotimes (b bytes)
    (aset flatmap
          (+ (* (aref (aref parsed b) 0) n)
             (aref (aref parsed b) 1))
          ?#))
  (aset costs source 0)
  (push source pqueue)

  (while-let ((node (pop pqueue))
              (_ (not (= node sink))))
    (aset visited node t)
    (mapc (lambda (neigh)
            (when-let ((cost (+ (aref costs node) 1))
                       (_ (<= cost (or (aref costs neigh)
                                       most-positive-fixnum))))
              (aset previous neigh node)
              (aset costs neigh cost)
              (unless (memq neigh pqueue)
                (push neigh pqueue))))
          (neighbors node flatmap visited n))

    (cl-sort pqueue (lambda (u v) (< (or (aref costs u)
                                        most-positive-fixnum)
                                     (or (aref costs v)
                                         most-positive-fixnum)))))
  (let ((pos sink)
        (path))

    (aset flatmap source ?S)
    (while-let ((prev (aref previous pos))
                (_ (not (= pos source))))
      (aset flatmap pos ?O)
      (push pos path)
      (setq pos prev))

    (aset flatmap sink ?s)
    (message "%s" (print-map flatmap n))
    (length path)))
#+end_src

#+RESULTS:
: 22

#+call: shortest-path-count(input=input-file("input-18.txt"),n=71,bytes=1024)

#+RESULTS:
: 364

#+name: shortest-path-cutoff
#+begin_src elisp :var input=example-18a :var n=7 :var min-bytes=12
(defun print-map (map n)
  "prints the map as matrix"
  (mapconcat 'identity (mapcar 'concat (seq-split map n)) "\n"))

(defun neighbors (pos map visited n)
  "get list of valid (non-wall) neighbors"
  (let ((neighs))
    (mapc (lambda (move) (when-let ((y (+ (/ pos n) (car move)))
                                    (x (+ (% pos n) (cdr move)))
                                    (node (+ (* y n) x))
                                    (_ (and (< -1 x n)
                                            (< -1 y n)
                                            (not (= (aref map node) ?#))
                                            (not (aref visited node)))))
                           (push node neighs)))
          '((-1 . 0) (1 . 0) (0 . -1) (0 . 1)))
    neighs))

(defun dijkstra-reachable-p (map source sink n)
  "return non-nill if dijkstra on map from source to sink reaches"
  (let* ((visited (make-vector (* n n) nil))
         (costs (make-vector (* n n) nil))
         (previous (make-vector (* n n) nil))
         (pqueue))
    (aset costs source 0)
    (push source pqueue)

    (while-let ((node (pop pqueue))
                (_ (not (= node sink))))
      (aset visited node t)
      (mapc (lambda (neigh)
              (when-let ((cost (+ (aref costs node) 1))
                         (_ (<= cost (or (aref costs neigh)
                                         most-positive-fixnum))))
                (aset previous neigh node)
                (aset costs neigh cost)
                (unless (memq neigh pqueue)
                  (push neigh pqueue))))
            (neighbors node flatmap visited n))

      (cl-sort pqueue (lambda (u v) (< (or (aref costs u)
                                           most-positive-fixnum)
                                       (or (aref costs v)
                                           most-positive-fixnum)))))
    (let ((pos sink)
          (path))

      (while-let ((prev (aref previous pos))
                  (_ (not (= pos source))))
        (push pos path)
        (setq pos prev))
      ;; (message "%s" path))
      )
    (aref previous sink)))


(let* ((parsed (vconcat (mapcar (lambda (l) (vconcat (reverse (mapcar 'string-to-number
                                                                      (s-split "," l)))))
                                (s-lines (s-trim input)))))
       (flatmap (make-vector (* n n) ?.))
       (source 0)
       (sink (1- (length flatmap)))
       (bytes min-bytes)
       (done nil))
  (dotimes (b bytes)
    (aset flatmap
          (+ (* (aref (aref parsed b) 0) n)
             (aref (aref parsed b) 1))
          ?#))

  (while (and (dijkstra-reachable-p flatmap source sink n)
              (< bytes (length parsed)))
    (setq bytes (1+ bytes))
    (when (< bytes (length parsed))
      (aset flatmap
            (+ (* (aref (aref parsed bytes) 0) n)
               (aref (aref parsed bytes) 1))
            ?#)))
  (if-let ((_ (< bytes (length parsed)))
           (byte (aref parsed bytes)))
      (format "%d,%d" (aref byte 1) (aref byte 0))
    nil))
  #+end_src

  #+RESULTS: shortest-path-cutoff
  : 6,1

  #+call: shortest-path-cutoff(input=input-file("input-18.txt"),n=71,min-bytes=1024)
