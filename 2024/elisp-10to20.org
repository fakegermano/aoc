#+title: Elisp 10to20

#+name: input-file
#+begin_src elisp :var fname=""
(f-read fname)
#+end_src


* Day 11

#+name: example-11a
#+begin_example
125 17
#+end_example

#+name: simulate-blinks
#+begin_src elisp :var input=example-11a :var blinks=6
(defun split-digits-evenp (number)
  "splits the digits of a number in half if even else return nil"
  (when-let* ((digits (number-to-string number))
              (len (length digits))
              (_ (cl-evenp len))
              (mid (/ len 2)))
    (mapcar 'string-to-number (list (substring digits 0 mid)
                                    (substring digits mid len)))))
(defun blink-sim (stones blinks)
  "return len of arrengement after blinks"
  (let ((memo (make-hash-table)))
    (puthash 0 '(1) memo)
    (puthash 1 '(2024) memo)
    (dotimes (i blinks)
      (setq stones (apply 'append (mapcar (lambda (stone)
                                     (or (gethash stone memo)
                                         (puthash stone (if-let ((split (split-digits-evenp stone)))
                                                            split
                                                          (list (* stone 2024)))
                                                  memo)))
                                   stones))))
    (length stones)))

(let* ((stones (mapcar 'string-to-number (s-split " " (s-trim input)))))
  (blink-sim stones blinks))
#+end_src

#+RESULTS: simulate-blinks
: 22

#+call: simulate-blinks(input=input-file("input-11.txt"),blinks=25)

#+name: count-blink
#+begin_src elisp :var input=example-11a :var blinks=6
(defun split-digits-evenp (number)
  "splits the digits of a number in half if even else return nil"
  (when-let* ((digits (number-to-string number))
              (len (length digits))
              (_ (cl-evenp len))
              (mid (/ len 2)))
    (mapcar 'string-to-number (list (substring digits 0 mid)
                                    (substring digits mid len)))))

(defun blink-stone (stone blink-memo)
  "return the list of the result of blinking to the stone"
  (or (gethash stone blink-memo)
      (puthash stone (if-let ((split (split-digits-evenp stone)))
                         split
                       (list (* stone 2024)))
               blink-memo)))

(defun print-count (stones-count)
  "print stones count hash table"
  (let ((counts))
    (maphash (lambda (stone count)
               (push (list stone count) counts))
             stones-count)
    (message "%s" counts)))

(defun blink (stones blink-memo)
  "count number of stones after blinks"
  ;;(print-count stones)
  (let ((next-stones (make-hash-table)))
    (maphash (lambda (stone count)
               (mapc (lambda (next-stone)
                       (if-let ((next-count (gethash next-stone next-stones)))
                           (puthash next-stone (+ next-count count) next-stones)
                         (puthash next-stone count next-stones))
                       ;;(print-count next-stones)
                       )
                     (blink-stone stone blink-memo)))
             stones)
    next-stones))

(let* ((stones (mapcar 'string-to-number (s-split " " (s-trim input))))
       (stones-count (make-hash-table))
       (blink-memo (make-hash-table))
       (total 0))
  (mapc (lambda (stone)
          (if-let ((count (gethash stone stones-count)))
              (puthash stone (1+ count) stones-count)
            (puthash stone 1 stones-count)))
        stones)
  (puthash 0 '(1) blink-memo)
  (dotimes (i blinks)
    (setq stones-count (blink stones-count blink-memo)))
  (maphash (lambda (_ count) (setq total (+ total count))) stones-count)
  total)
#+end_src

#+RESULTS: count-blink
: 22

#+call: count-blink(blinks=25)

#+RESULTS:
: 55312

#+call: count-blink(input=input-file("input-11.txt"),blinks=25)


#+call: count-blink(input=input-file("input-11.txt"),blinks=75)



* Day 12

#+name: example-12a
#+begin_example
AAAA
BBCD
BBCC
EEEC
#+end_example

#+name: example-12b
#+begin_example
OOOOO
OXOXO
OOOOO
OXOXO
OOOOO
#+end_example

#+name: example-12c
#+begin_example
RRRRIICCFF
RRRRIICCCF
VVRRRCCFFF
VVRCCCJFFF
VVVVCJJCFE
VVIVCCJJEE
VVIIICJJEE
MIIIIIJJEE
MIIISIJEEE
MMMISSJEEE
#+end_example

#+name: calculate-price
#+begin_src elisp :var input=example-12a
(defun flood-fill-area-perimeter (farm seed)
  "uses flood-fill algorithm to find area and perimeter"
  (let* ((m (length farm))
         (n (length (aref farm 0)))
         (plant (aref (aref farm (car seed)) (cdr seed)))
         (stack)
         (area)
         (perimeter)
         (insidep (lambda (node)
                    (let ((inside (and (>= (car node) 0)
                                       (< (car node) m)
                                       (>= (cdr node) 0)
                                       (< (cdr node) n)
                                       (= (aref (aref farm (car node)) (cdr node)) plant))))
                      inside))))
    (push seed stack)
    (while-let ((node (pop stack)))
      (if (funcall insidep node)
          (unless (member node area)
            (push node area)
            (mapc (lambda (side)
                    (push (cons (+ (car node) (car side)) (+ (cdr node) (cdr side)))
                          stack))
                  '((-1 . 0) (1 . 0) (0 . -1) (0 . 1))))
        (push node perimeter)))
    ;;(message "%c %s %s" plant area perimeter)
    (list area perimeter)))

(let* ((farm (vconcat (mapcar 'string-to-vector (s-lines (s-trim input)))))
       (prices)
       (m (length farm))
       (n (length (aref farm 0)))
       (visited (make-vector (* m n) nil)))
  (dotimes (i m)
    (dotimes (j n)
      (when-let ((seed (cons i j))
                 (v (not (aref visited (+ (* i n) j))))
                 (price (flood-fill-area-perimeter farm seed))
                 (plant (aref (aref farm i) j)))
        ;; make sure to mark all nodes in region as visited to avoid double work
        (mapc (lambda (node)
                (aset visited (+ (* (car node) n) (cdr node)) t))
              (car price))
        (push (cons plant price) prices))))
  (apply '+ (mapcar (lambda (p)
                      (let* ((area (length (cadr p)))
                             (perimeter (length (caddr p)))
                             (plant (car p))
                             (price (* area perimeter)))
                        ;;(message "%c: [A:%d P:%d] %d" plant area perimeter price)
                        price))
                    prices)))
#+end_src

#+RESULTS:
: 140

#+call: calculate-price(input=example-12b)

#+RESULTS:
: 772


#+call: calculate-price(input=example-12c)

#+RESULTS:
: 1930

#+call: calculate-price(input=input-file("input-12.txt"))

