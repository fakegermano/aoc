#+title: Elisp AoC tryouts

* Day 1
https://adventofcode.com/2024/day/1

#+name: example-1a
#+begin_example
3   4
4   3
2   5
1   3
3   9
3   3
#+end_example

#+name: input-file
#+begin_src elisp :var fname=""
(f-read fname)
#+end_src


#+name: process-input
#+begin_src elisp :var input=example-1a()
(mapcar (lambda (e) (mapcar #'string-to-number (s-split "\s+" e))) (s-lines (s-trim input)))
#+end_src

#+RESULTS: process-input
| 3 | 4 |
| 4 | 3 |
| 2 | 5 |
| 1 | 3 |
| 3 | 9 |
| 3 | 3 |

#+name: calculate-1a
#+begin_src elisp :var input=process-input()
(let ((left (sort (mapcar #'car input) #'<))
      (right (sort (mapcar (lambda (l) (cadr l)) input) #'<))
      (difference 0))
  (cl-loop for l in left for r in right collect (setq difference (+ difference (abs (- l r)))))
  difference)
#+end_src

#+RESULTS: calculate-1a
: 11

#+call: calculate-1a(process-input(input-file("input-1.txt")))

#+name: calculate-1b
#+begin_src elisp :var input=process-input()
(let ((left (sort (mapcar #'car input) #'<))
      (right (sort (mapcar (lambda (l) (cadr l)) input) #'<))
      (total 0))
  (cl-loop for l in left collect (setq total (+ total (* l (count l right)))))
  total)
#+end_src

#+RESULTS:
: 31

#+call: calculate-1b(process-input(input-file("input-1.txt")))

* Day 2

#+name: example-2a
#+begin_example
7 6 4 2 1
1 2 7 8 9
9 7 6 2 1
1 3 2 4 5
8 6 4 4 1
1 3 6 7 9
#+end_example

#+name: calculate-2a
#+begin_src elisp :var input=process-input(example-2a)
(defun safe (level)
  "checks if a level is safe aka only increasing, only decreasing and by 1, 2 or 3"
  (let ((diff (mapcar (lambda (l) (- (car l) (cdr l)))
                      (cl-pairlis level (cdr level)))))
    (or (cl-every (lambda (l) (and (< l 0)
                                   (> l -4))) diff)
        (cl-every (lambda (l) (and (> l 0)
                                   (< l 4))) diff))))
(cl-count t (mapcar #'safe input))
#+end_src

#+RESULTS:
: 2

#+call: calculate-2a(process-input(input-file("input-2.txt")))


#+name: calculate-2b
#+begin_src elisp :var input=process-input(example-2a)
(defun safe (level)
  "checks if a level is safe aka only increasing, only decreasing and by 1, 2 or 3"
  (let ((diff (mapcar (lambda (l) (- (car l) (cdr l)))
                      (cl-pairlis level (cdr level)))))
    (or (cl-every (lambda (l) (and (< l 0)
                                   (> l -4))) diff)
        (cl-every (lambda (l) (and (> l 0)
                                   (< l 4))) diff))))
(defun safe-modified (level)
  "checks if a level is safe aka only increasing, only decreasing and by 1, 2 or 3"
  (let ((sublevels (cons level (cl-mapcar (lambda (x i) (append (cl-subseq level 0 i) (cl-subseq level (1+ i)))) level (number-sequence 0 (length level))))))
    (cl-count t (mapcar 'safe sublevels))))

(cl-count-if (lambda (x) (> x 0)) (mapcar #'safe-modified input))
#+end_src

#+RESULTS: calculate-2b
: 4

#+call: calculate-2b(process-input(input-file("input-2.txt")))

* Day 3
#+name: example-3a
#+begin_example
xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))
#+end_example

#+name: extract-3a
#+begin_src elisp :var input=example-3a
(cl-reduce #'+ (mapcar (lambda (m) (cl-reduce #'* (mapcar #'string-to-number (cdr m))))
                       (s-match-strings-all (rx "mul(" (group (** 1 3 num)) "," (group (** 1 3 num)) ")") input)))
#+end_src

#+RESULTS: extract-3a
: 161

#+call: extract-3a(input-file("input-3.txt"))

#+RESULTS:
: 182780583

#+name: example-3b
#+begin_example
xmul(2,4)&mul[3,7]!^don't()_mul(5,5)+mul(32,64](mul(11,8)undo()?mul(8,5))
#+end_example

#+name: extract-3b
#+begin_src elisp :var input=example-3b
(cl-reduce #'+ (let* ((mult 1))
                 (mapcar (lambda (m) (cond ((s-equals? (cadr m) "mul") (* mult (string-to-number (caddr m)) (string-to-number (cadddr m))))
                                           ((s-equals? (cadr m) "do") (setq mult 1) 0)
                                           ((s-equals? (cadr m) "don't") (setq mult 0) 0)))
                         (s-match-strings-all (rx (or (: (group-n 1 "mul") "(" (group (** 1 3 num)) "," (group (** 1 3 num)) ")")
                                                      (: (group-n 1 "do") "()")
                                                      (: (group-n 1 "don't") "()"))) input))))
#+end_src

#+RESULTS: extract-3b
: 48

#+call: extract-3b(input-file("input-3.txt"))

#+RESULTS:
: 90772405

* Day 4

#+name: example-4a
#+begin_example
MMMSXXMASM
MSAMXMSMSA
AMXSXMAAMM
MSAMASMSMX
XMASAMXAMM
XXAMMXXAMA
SMSMSASXSS
SAXAMASAAA
MAMMMXMMMM
MXMXAXMASX
#+end_example

#+name: process-input-chars
#+begin_src elisp :var input=example-4a
(mapcar #'string-to-list (s-lines (s-trim input)))
#+end_src

#+RESULTS: process-input-chars
| 77 | 77 | 77 | 83 | 88 | 88 | 77 | 65 | 83 | 77 |
| 77 | 83 | 65 | 77 | 88 | 77 | 83 | 77 | 83 | 65 |
| 65 | 77 | 88 | 83 | 88 | 77 | 65 | 65 | 77 | 77 |
| 77 | 83 | 65 | 77 | 65 | 83 | 77 | 83 | 77 | 88 |
| 88 | 77 | 65 | 83 | 65 | 77 | 88 | 65 | 77 | 77 |
| 88 | 88 | 65 | 77 | 77 | 88 | 88 | 65 | 77 | 65 |
| 83 | 77 | 83 | 77 | 83 | 65 | 83 | 88 | 83 | 83 |
| 83 | 65 | 88 | 65 | 77 | 65 | 83 | 65 | 65 | 65 |
| 77 | 65 | 77 | 77 | 77 | 88 | 77 | 77 | 77 | 77 |
| 77 | 88 | 77 | 88 | 65 | 88 | 77 | 65 | 83 | 88 |

#+name: find-xmas
#+begin_src elisp :var input=process-input-chars(example-4a)
(defun count-xmas (list-of-chars)
  ""
  (cl-reduce #'+ (mapcar (lambda (chars)
                           (let* ((start 0)
                                  (count 0)
                                  (str (concat chars)))
                             (while (string-match "XMAS" str start)
                               (setq count (1+ count))
                               (setq start (match-end 0)))
                             count))
                         list-of-chars)))
(let* ((transposed (apply #'cl-mapcar #'list input))
       (n (length input))
       (diagonal-lr (make-list (1- (* 2 n)) nil))
       (diagonal-rl (make-list (1- (* 2 n)) nil)))
  (dotimes (i n)
    (dotimes (j n)
      (setf (elt diagonal-lr (+ i j)) (cons (nth j (nth i input)) (nth (+ i j) diagonal-lr)))
      (setf (elt diagonal-rl (+ i j)) (cons (nth j (nth (1- (- n i)) input)) (nth (+ i j) diagonal-rl)))))
  (cl-reduce #'+ (mapcar #'count-xmas (list input (mapcar #'reverse input)
                                            transposed (mapcar #'reverse transposed)
                                            diagonal-lr (mapcar #'reverse diagonal-lr)
                                            diagonal-rl (mapcar #'reverse diagonal-rl)))))
#+end_src

#+RESULTS: find-xmas
: 18

#+call: find-xmas(process-input-chars(input-file("input-4.txt"))))

#+name: find-x-mas
#+begin_src elisp :var input=process-input-chars(example-4a)
(let* ((n (length input)) (out) (count 0))
  (dotimes (i n)
    (dotimes (j n)
      (let* ((j- (when (> j 0) (1- j)))
             (j+ (when (< j (1- n)) (1+ j)))
             (i- (when (> i 0) (1- i)))
             (i+ (when (< i (1- n)) (1+ i)))
             (m (nth j (nth i input)))
             (tl (when (and j- i-)
                   (nth j- (nth i- input))))
             (br (when (and j+ i+)
                   (nth j+ (nth i+ input))))
             (bl (when (and j- i+)
                   (nth j- (nth i+ input))))
             (tr (when (and j+ i-)
                   (nth j+ (nth i- input))))
             (dlr (when (and tl br)
                    (concat (list tl m br))))
             (drl (when (and bl tr)
                    (concat (list bl m tr)))))
        (when (and dlr drl
                   (or (string= drl "MAS")
                       (string= drl "SAM"))
                   (or (string= dlr "MAS")
                       (string= dlr "SAM")))
          (setq count (1+ count))
          (push (list (string m) dlr drl) out)))))
  out
  count)
#+end_src

#+RESULTS: find-x-mas
: 9

#+call: find-x-mas(process-input-chars(input-file("input-4.txt")))

* Day 5

#+name: example-5a
#+begin_example
47|53
97|13
97|61
97|47
75|29
61|13
75|53
29|13
97|29
53|29
61|53
97|53
61|29
47|13
75|47
97|75
47|61
75|61
47|29
75|13
53|13

75,47,61,53,29
97,61,53,29,13
75,29,13
75,97,47,61,53
61,13,29
97,13,75,29,47
#+end_example

#+name: parse-rules-updates
#+begin_src elisp :var input=example-5a
(defun print-matrix (matrix n)
  "print adj matrix as 0 and 1"
  (mapcar (lambda (r) (mapconcat (lambda (c) (if c "1" "0")) r "")) (seq-split matrix n)))
(let* ((parsed (mapcar 's-lines (s-split "\n\n" (s-trim input))))
       (rules (mapcar (lambda (r) (mapcar #'string-to-number (s-split "|" r))) (car parsed)))
       (updates (mapcar (lambda (u) (mapcar #'string-to-number (s-split "," u))) (cadr parsed)))
       (n (max (max (apply #'max (apply #'append rules)))
               (max (apply #'max (apply #'append updates)))))
       (matrix (make-vector (1- (* n n)) nil)))
  (dolist (e rules)
    (let* ((i (1- (car e)))
           (j (1- (cadr e)))
           (idx (+ (* i n) j)))
      (aset matrix idx (not (aref matrix idx)))))
  (cl-reduce #'+ (mapcar (lambda (up)
                           (if (not (seq-contains-p (mapcar (lambda (e) (aref matrix (+ (* (1- (car e)) n) (1- (cdr e))))) (cl-pairlis up (cdr up)))
                                                    nil))
                               (nth (/ (length up) 2) up)
                             0))
                         updates)))
#+end_src

#+RESULTS: parse-rules-updates
: 143

#+call: parse-rules-updates(input-file("input-5.txt"))


#+name: parse-rules-updates-correct
#+begin_src elisp :var input=example-5a
(defun print-matrix (matrix n)
  "print adj matrix as 0 and 1"
  (mapcar (lambda (r) (mapconcat (lambda (c) (if c "1" "0")) r "")) (seq-split matrix n)))
(let* ((parsed (mapcar 's-lines (s-split "\n\n" (s-trim input))))
       (rules (mapcar (lambda (r) (mapcar #'string-to-number (s-split "|" r))) (car parsed)))
       (updates (mapcar (lambda (u) (mapcar #'string-to-number (s-split "," u))) (cadr parsed)))
       (n (max (max (apply #'max (apply #'append rules)))
               (max (apply #'max (apply #'append updates)))))
       (matrix (make-vector (1- (* n n)) nil)))
  (dolist (e rules)
    (let* ((i (1- (car e)))
           (j (1- (cadr e)))
           (idx (+ (* i n) j)))
      (aset matrix idx (not (aref matrix idx)))))
  (cl-reduce #'+ (mapcar (lambda (up)
                           (if (seq-contains-p (mapcar (lambda (e) (aref matrix (+ (* (1- (car e)) n) (1- (cdr e))))) (cl-pairlis up (cdr up)))
                                               nil)
                               (nth (/ (length up) 2) (seq-sort (lambda (u1 u2) (aref matrix (+ (* (1- u1) n) (1- u2)))) up))
                             0))
                         updates)))
#+end_src

#+RESULTS: parse-rules-updates-correct
: 123

#+call: parse-rules-updates-correct(input-file("input-5.txt"))

